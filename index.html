<html lang="en">
  <head>
    <title>Terrain Maps</title>
    <link rel="stylesheet" type="text/css" href="style.css">
    <script type="text/javascript" src="https://code.jquery.com/jquery-2.2.3.min.js"></script>
    <script type="text/javascript" src="landmap.js"></script>
    <script type="text/javascript" src="main.js"></script>
  </head>
  <body>
    <!-- header -->
    <div class="container">
      <div class="row">
        <h1>Terrain Maps</h1>
        <h4>Generating and manipulating terrain maps using Diamond-Square, smoothing, and erosion algorithms.</h4>
        <p>I've been messing around with different terrain smoothing algorithms on Diamond-Square-generated maps. I'm putting them here to so I remember them and write them out a little more clearly. All maps use the Diamond-Square algorithm
          to begin with. After than, some use smoothing passes, which essentially involves iterating over every point and setting it to be the average of all neighboring points within an X radius. Others involve erosion algorithms.</p>
        <p>All maps are rendered with heighest points in white, lowest ones in black. Values are relative to minimum and maxmimum values, meaning that if a map was generated with a single point that is 100, and all others being around 5, it's going to
          look pretty dark. All maps are 256 by 256. </p>
        <p><strong>NOTE: Some of these map sets take upwards of 45 seconds to generate on a computer with a solid processor. Your milage may vary.</strong></p>
      </div>
    </div>
    <!-- container-1 -->
    <div class="container">
      <hr>
      <div class="row">
        <h2>Standard Diamond-Square Algorithm</h2>
        <p>
          Diamon-Square with smoothing of 10, and 20.
          <button class="run button-primary" id="standard">GENERATE</button>
        </p>
      </div>
      <div class="set-of" id="container-standard"></div>
      <hr>
    </div>
    <!-- container-2 -->
    <div class="container">
      <div class="row">
        <h2>Combining Diamond-Square Maps</h2>
        <p>
          Combining a DS, DS smoothed (10), and DS smoothed (20) maps. This is done by generating <code>standard</code>, then <code>standard-two</code>, a completely different map. Then using each of these to generate a smoothed version of themselves. Then
          we can combine standard with <code>standard-10</code>, using <code>standard-two-20</code> as the map controlling which parts of the map are used for the result. For example the higher the value of a given point on <code>standard-two-20</code>, the
          stronger the value taken from <code>standard</code> and assigned to the resulting map. The lower the value of a given point on <code>standard-two-20</code>, the stronger the value taken from <code>standard-10</code> and assigned to the resulting
          map.
        </p>
        <p>
          This allows us to generate a map that has terrain that is smooth in some parts, and rugged in other parts.
          <br>The final <code>reverse</code> map, is with the <code>standard</code> and <code>standard-10</code> maps swapped, so the smooth and rugged values are reversed.
          <button class="run button-primary" id="combined">GENERATE</button>
        </p>
      </div>
      <div class="set-of" id="container-combined"></div>
      <hr>
    </div>
    <!-- container-3 -->
    <div class="container">
      <div class="row">
        <h2>Greedy Raindrop Erosion Algorithm</h2>
        <p>
          For each point on the map, steal a certain percentage off the tallest neighbor. Results in blochy, plateau-like formations.
          <button class="run button-primary" id="grd">GENERATE</button>
        </p>
      </div>
      <div class="set-of" id="container-grd"></div>
      <hr>
    </div>
    <!-- container-4 -->
    <div class="container">
      <div class="row">
        <h2>Simple Erosion Algorithm</h2>
        <p>
          Randomly place a "droplet" of water on the map. For a number of iterations, let the droplet roll to it's nearest neighbor, eroding it's current point on the map if the droplet has not reached it carrying-capacity of sediment. If it has reached
          it's carrying capacity, deposit sediment on that point. Repeat this process with many more droplets.
          <button class="run button-primary" id="simpleErosion">GENERATE</button>
        </p>
      </div>
      <div class="set-of" id="container-simpleErosion"></div>
      <hr>
    </div>
    <!-- container-5 -->
    <div class="container">
      <div class="row">
        <h2>Complex Erosion Algorithm</h2>
        <p>
          Like <em>Simple Erosion Algorithm</em> but it uses velocity (with a minimum velocity ensure), slope (with a minimum slope ensured as well) to calculate carring capacity and depositing.
          <button class="run button-primary" id="complexErosion">GENERATE</button>
        </p>
      </div>
      <div class="set-of" id="container-complexErosion"></div>
      <hr>
    </div>
    <!-- hidden canvas for rendering-->
    <canvas class="hidden" id="tmp" width="256" height="256"></canvas>
  </body>
</html>
